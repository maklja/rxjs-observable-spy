import { Observable, Subscription } from 'rxjs';
import { TestScheduler } from 'rxjs/testing';
import {
	AlreadySubscribedError,
	NotSubscribedError,
	UnexpectedObservableCompleteError,
} from '../errors';
import { CompleteListener, ErrorListener, NextListener, SubscribedSpy } from './SubscribedSpy';

export interface ObserverSpyConfig {
	useTestScheduler: boolean;
}

export class ObservableSpy<T> implements SubscribedSpy<T> {
	private readonly nextListeners: NextListener<T>[] = [];
	private readonly errorListeners: ErrorListener<T>[] = [];
	private readonly completeListeners: CompleteListener<T>[] = [];
	private readonly values: T[] = [];
	private error: unknown | null = null;
	private subscription: Subscription | null = null;
	private isCompleted = false;

	/**
	 * Simple spy class that is used to test observables.
	 * This spy is immutable and once complete or error event is received there is no way to resubscribe spy to the observable.
	 * Instead create a new instance of observable spy.
	 *
	 * @typeParam T - Type of values that are generated by the observable.
	 *
	 * @param observable - Rxjs observable that will be tested by spy.
	 * @param config - Spy configuration.
	 */
	constructor(private observable: Observable<T>, private config?: ObserverSpyConfig) {}

	/**
	 * Subscribes spy to the observable that is being tested.
	 *
	 * @throws {@link AlreadySubscribedError}
	 * This exception is thrown if spy is already subscribed to the observable.
	 *
	 * @returns Subscription from the tested observable.
	 */
	public subscribe(): Subscription {
		if (this.subscription) {
			throw new AlreadySubscribedError();
		}

		return this.config?.useTestScheduler
			? this.subscribeSpyWithTestScheduler()
			: this.subscribeSpy();
	}

	public getValues(): T[] {
		return [...this.values];
	}

	public getValuesLength() {
		return this.values.length;
	}

	public receivedComplete() {
		return this.isCompleted;
	}

	public receivedError() {
		return this.error != null;
	}

	public getError<T = unknown>() {
		return this.receivedError() ? (this.error as T) : null;
	}

	public unsubscribe() {
		this.dispose();
	}

	/**
	 * Register a listener that will be invoked when the next event is received from a tested observable.
	 *
	 * @param listener - Listener function to register.
	 *
	 * @returns True if the {@link listener} is successfully registered within the spy, otherwise false.
	 */
	public addNextListener(listener: NextListener<T>): boolean {
		if (this.nextListeners.includes(listener) || this.isClosed()) {
			return false;
		}

		this.nextListeners.push(listener);

		return true;
	}

	/**
	 * Removes registered next listener from the spy.
	 * Note that listeners are compared by reference.
	 *
	 * @param listener - Listener function to unregister.
	 *
	 * @returns True if the {@link listener} is successfully removed from the spy, otherwise false.
	 */
	public removeNextListener(listener: NextListener<T>): boolean {
		const listenerIndex = this.nextListeners.indexOf(listener);
		if (listenerIndex === -1) {
			return false;
		}

		this.nextListeners.splice(listenerIndex, 1);

		return true;
	}

	/**
	 * Register a listener that will be invoked when the error event is received from a tested observable.
	 *
	 * @param listener - Listener function to register.
	 *
	 * @returns True if the {@link listener} is successfully registered within the spy, otherwise false.
	 */
	public addErrorListener(listener: ErrorListener<T>): boolean {
		if (this.errorListeners.includes(listener) || this.isClosed()) {
			return false;
		}

		this.errorListeners.push(listener);

		return true;
	}

	/**
	 * Removes registered error listener from the spy.
	 * Note that listeners are compared by reference.
	 *
	 * @param listener - Listener function to unregister.
	 *
	 * @returns True if the {@link listener} is successfully removed from the spy, otherwise false.
	 */
	public removeErrorListener(listener: ErrorListener<T>): boolean {
		const listenerIndex = this.errorListeners.indexOf(listener);
		if (listenerIndex === -1) {
			return false;
		}

		this.errorListeners.splice(listenerIndex, 1);

		return true;
	}

	/**
	 * Register a listener that will be invoked when the complete event is received from a tested observable.
	 *
	 * @param listener - Listener function to register.
	 *
	 * @returns True if the {@link listener} is successfully registered within the spy, otherwise false.
	 */
	public addCompleteListener(listener: CompleteListener<T>): boolean {
		if (this.completeListeners.includes(listener) || this.isClosed()) {
			return false;
		}

		this.completeListeners.push(listener);

		return true;
	}

	/**
	 * Removes registered complete listener from the spy.
	 * Note that listeners are compared by reference.
	 *
	 * @param listener - Listener function to unregister.
	 *
	 * @returns True if the {@link listener} is successfully removed from the spy, otherwise false.
	 */
	public removeCompleteListener(listener: CompleteListener<T>): boolean {
		const listenerIndex = this.completeListeners.indexOf(listener);
		if (listenerIndex === -1) {
			return false;
		}

		this.completeListeners.splice(listenerIndex, 1);

		return true;
	}

	public onComplete(): Promise<T[]> {
		if (!this.subscription) {
			throw new NotSubscribedError();
		}

		return new Promise((resolve, reject) => {
			if (this.receivedComplete()) {
				return resolve(this.getValues());
			}

			if (this.receivedError()) {
				return reject(this.getError());
			}

			this.addCompleteListener(() => resolve(this.getValues()));
			this.addErrorListener((e) => reject(e));
		});
	}

	public onError<T = unknown>(): Promise<T> {
		if (!this.subscription) {
			throw new NotSubscribedError();
		}

		return new Promise((resolve, reject) => {
			if (this.receivedComplete()) {
				return reject(new UnexpectedObservableCompleteError());
			}

			if (this.error != null) {
				return resolve(this.error as T);
			}

			this.addCompleteListener(() => reject(new UnexpectedObservableCompleteError()));
			this.addErrorListener((e) => resolve(e as T));
		});
	}

	private dispose() {
		if (this.subscription) {
			this.subscription.unsubscribe();
		}

		this.nextListeners.splice(0, this.nextListeners.length);
		this.errorListeners.splice(0, this.errorListeners.length);
		this.completeListeners.splice(0, this.completeListeners.length);
	}

	private isClosed(): boolean {
		return this.receivedComplete() || this.receivedError();
	}

	private subscribeSpyWithTestScheduler() {
		const testScheduler = new TestScheduler(
			/* istanbul ignore next */
			() => {
				return;
			},
		);

		return testScheduler.run(() => this.subscribeSpy());
	}

	private subscribeSpy() {
		this.subscription = this.observable.subscribe({
			next: (val) => {
				this.values.push(val);
				this.notifyNext(val, this.values.length - 1);
			},
			error: (e: unknown) => {
				this.error = e;
				this.notifyError(e);
				this.dispose();
			},
			complete: () => {
				this.isCompleted = true;
				this.notifyCompleted();
				this.dispose();
			},
		});

		return this.subscription;
	}

	private notifyNext(val: T, index: number) {
		this.nextListeners.forEach((l) => l(val, index, this));
	}

	private notifyError(e: unknown) {
		this.errorListeners.forEach((l) => l(e, this));
	}

	private notifyCompleted() {
		this.completeListeners.forEach((l) => l(this));
	}
}
